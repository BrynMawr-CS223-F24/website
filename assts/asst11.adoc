include::header.adoc[]

:title: Assignment 11: Where others fear to thread
:Author Initials: ASN
:Date:    2020-08-15
:Revision: 0.1
:stem: latexmath
:ASST: A11

= {title}

*Due Sunday, December 1 before midnight (No late submissions accepted)*

The goals for this assignment are:

* Implement multi-threaded algorithms using the pthread library
* Implement a tree data structure
* Work with OS system calls

[discrete]
== Update your repository

Do a *fetch upstream* to obtain the basecode for this assignment. 

Using the command line

* Open terminal and change your current directory to your assignment repository.
* Run the command `git fetch upstream`
* Run the command `git merge upstream/master`

Your repository should now contain a new folder named `{ASST}`.

The `fetch` and `merge` commands update your repository with any changes from the original.

:sectnums:

= Grep

This question implements a simplified version of the bash command `grep`. Grep searches a list of files 
for a given keyword or expression. For example, the following command searches for the keyword `public` 
in a list of source files. We use the `find` command to generate the list of source files to search.

[code, subs="quotes"]
----
$ **grep public `find code -name "*.h"`**
code/Seal.h:class Seal : public Animal
code/Seal.h:public:
code/Walk.h:class Walk : public Locomotion
code/Walk.h:public:
code/Animal.h:public:
code/Duck.h:class Duck : public Bird
code/Duck.h:public:
code/Locomotion.h:public:
code/Fly.h:class Fly : public Locomotion
code/Fly.h:public:
code/Bird.h:class Bird : public Animal
code/Bird.h:public:
code/Swim.h:class Swim : public Locomotion
code/Swim.h:public:
code/Fish.h:class Fish : public Animal
code/Fish.h:public:
code/Whale.h:class Whale : public Fish
code/Whale.h:public:
----

In the file, `grep.c`, implement a program that uses N threads to search for a keyword 
in a set of files. 

[source, subs="quotes"]
----
$ **make grep**
gcc -g -Wall -Wvla -Werror grep.c -o grep -lpthreads
$ **./grep**
usage: ./grep <NumThreads> <Keyword> <Files>
$ **./grep 3 public `find code -name "*.h"`**
Searching 10 files for keyword: public
Thread 0 searching 4 files (3 to 7)
Thread 1 searching 3 files (7 to 10)
Thread 2 searching 3 files (10 to 13)
0) code/Seal.h:class Seal : public Animal
0) code/Seal.h:public:
0) code/Walk.h:class Walk : public Locomotion
0) code/Walk.h:public:
0) code/Animal.h:public:
0) code/Duck.h:class Duck : public Bird
2) code/Swim.h:class Swim : public Locomotion
1) code/Locomotion.h:public:
2) code/Swim.h:public:
0) code/Duck.h:public:
1) code/Fly.h:class Fly : public Locomotion
1) code/Fly.h:public:
2) code/Fish.h:class Fish : public Animal
2) code/Fish.h:public:
2) code/Whale.h:class Whale : public Fish
2) code/Whale.h:public:
1) code/Bird.h:class Bird : public Animal
1) code/Bird.h:public:
Elapsed time is 0.000979
Thread 0 found 7 lines containing keyword: public
Thread 1 found 5 lines containing keyword: public
Thread 2 found 6 lines containing keyword: public
----

Requirements:

* Your program should take the number of threads, keyword, and a list of files as command line arguments
* Subdivide the files among the N threads. Note that the number of files may not divide evenly between threads.
* Use a mutex to ensure that threads do not interrupt each others printing
* Print the totals and sub-division of files similarly to the output above
* Use the `fgets` to process the lines in each file
* Use the function `strstr` defined in `string.h` to search lines of text for the keyword. link:https://en.cppreference.com/w/c/string/byte/strstr[Documentation is here]

= Code Analysis

This question has two parts. In the first part, you will implement a search tree with string keys. 
In the second part, you will use the tree to store the source files from a directory, along with their 
dependency information. Similarly to your `grep` implementation, you will build the tree using multiple 
threads.

== Tree

In the file, `tree.c`, implement a binary search tree. Do not change the header
`tree.h`, nor the function declarations in `tree.c`. We recommend using the book
"Data Structures and Algorithm Analysis in C" by Mark Allen Weiss. See the
link:../index.html[course webpage for a link].

[code]
----

----

Requirements:

* You must not modify the basecode for `tree.h` or `tree.c`
* Your output should match the above and pass all tests

== Dependencies

A _dependency_ is a general software term for any software required by another. In this question, 
we will analyze dependencies between files, as determined by `#include` statements. For example, 
the file "Animal.h" depends on "string.h". We can represent such dependencies using a graph, where 
nodes represent files and directed edges represent dependencies. With this representation, a node 
with no outgoing edges has no dependencies.  

In the file, `dependency.c`, implement a program that uses N threads to build a binary search tree of a 
given set of files. The nodes of the binary search tree should also contain a list of dependencies that 
point to other nodes in the tree. This data structure should make it easy to look up a file by name and 
then trace through the dependencies between files.


Requirements:

* Use a mutex to avoid race conditions when setting up the tree and graph data structures

= Submit your work

Submit both your code and images.

1) Push your code work to github

[source]
----
$ git status
$ git add . 
$ git status
$ git commit -m "assignment complete"
$ git status
$ git push
$ git status
----


= Grading Rubric

*Assignment rubrics*

Grades are out of 4 points.

* (1 points) Grep
** (0.1 points) style and header comment
** (0.4 points) 
** (0.5 points) no memory errors
* (1 points) Tree
** (0.1 points) style and header comment
** (0.9 points) 
** (1 points) no memory errors
* (2 points) Dependencies
** (0.1 points) style and header comment
** (0.4 points) 
** (0.5 points) no memory errors

*Code rubrics*

For full credit, your C programs must be feature-complete, robust (e.g. run without memory errors or crashing) and 
have good style.

* Some credit lost for missing features or bugs, depending on severity of error
* -5% for style errors. See the link:../codingstandard.html[class coding style] here.
* -50% for memory errors
* -100% for failure to checkin work to Github
* -100% for failure to compile on linux using make

